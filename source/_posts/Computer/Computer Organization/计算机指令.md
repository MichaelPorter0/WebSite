---
title: 3.计算机指令
categories: 
- [计算机基础, 计算机组成原理]
date: 2020-10-17 18:37:21
tags:
- 计算机基础
- 计算机组成原理
---
# 1. 计算机指令
&ensp;&ensp; &ensp; 从软件工程师的角度来讲，CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。这里的计算机指令，就好比一门 CPU 能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。不同的 CPU 能够听懂的语言不太一样。比如，我们的个人电脑用的是 Intel 的 CPU，苹果手机用的是 ARM 的 CPU。这两者能听懂的语言就不太一样。类似这样两种 CPU 各自支持的语言，就是两组不同的计算机指令集，英文叫 Instruction Set。这里面的“Set”，其实就是数学上的集合，代表不同的单词、语法。所以，如果我们在自己电脑上写一个程序，然后把这个程序复制一下，装到自己的手机上，肯定是没办法正常运行的，因为这两者语言不通。而一台电脑上的程序，简单复制一下到另外一台电脑上，通常就能正常运行，因为这两台 CPU 有着相同的指令集，也就是说，它们的语言相通的。一个计算机程序，不可能只有一条指令，而是由成千上万条指令组成的。但是 CPU 里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作存储程序型计算机（Stored-program Computer）。

# 2. 汇编语言
&ensp;&ensp; &ensp;要让一段程序在一个 Linux 操作系统上跑起来，我们需要把整个程序翻译成一个汇编语言（ASM，Assembly Language）的程序，这个过程我们一般叫编译（Compile）成汇编代码。针对汇编代码，我们可以再用汇编器（Assembler）翻译成机器码（Machine Code）。这些机器码由“0”和“1”组成的机器语言表示。这一条条机器码，就是一条条的计算机指令。这样一串串的 16 进制数字，就是我们 CPU 能够真正认识的计算机指令。在一个 Linux 操作系统上，我们可以简单地使用 gcc 和 objdump 这样两条命令，把对应的汇编代码和机器码都打印出来。

&ensp;&ensp; &ensp;我们实际在用 GCC（GUC 编译器套装，GNU Compiler Collectipon）编译器的时候，可以直接把代码编译成机器码呀，为什么还需要汇编代码呢？原因很简单，你看着那一串数字表示的机器码，是不是摸不着头脑？但是即使你没有学过汇编代码，看的时候多少也能“猜”出一些这些代码的含义。
&ensp;&ensp; &ensp;因为汇编代码其实就是“给程序员看的机器码”，也正因为这样，机器码和汇编代码是一一对应的。我们人类很容易记住 add、mov 这些用英文表示的指令，而 8b 45 f8 这样的指令，由于很难一下子看明白是在干什么，所以会非常难以记忆。

# 3. 解析指令和机器码
&ensp;&ensp; &ensp;我们日常用的 Intel CPU，有 2000 条左右的 CPU 指令，一般来说，常见的指令可以分成五大类:

## 3.1 算术类指令。
&ensp;&ensp; &ensp;我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。
## 3.2 数据传输类指令。
&ensp;&ensp; &ensp;给变量赋值、在内存里读写数据，用的都是数据传输类指令。
## 3.3 逻辑类指令。
&ensp;&ensp; &ensp;逻辑上的与或非，都是这一类指令。
## 3.4 条件分支类指令。
&ensp;&ensp; &ensp;日常我们写的“if/else”，其实都是条件分支类指令。
## 3.5 无条件跳转指令。
&ensp;&ensp; &ensp;写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。

![avatar](/img/computer/计算机指令.jpeg)

# 4. MIPS指令集

&ensp;&ensp; &ensp;不同的 CPU 有不同的指令集，也就对应着不同的汇编语言和不同的机器码。MIPS 是一组由 MIPS 技术公司在 80 年代中期设计出来的 CPU 指令集。

&ensp;&ensp; &ensp;MIPS 的指令是一个 32 位的整数，高 6 位叫操作码（Opcode），也就是代表这条指令具体是一条什么样的指令，剩下的 26 位有三种格式，分别是 R、I 和 J。

&ensp;&ensp; &ensp;R 指令是一般用来做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。

&ensp;&ensp; &ensp;I 指令，则通常是用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。这个时候，没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或者一个常数。

&ensp;&ensp; &ensp;J 指令就是一个跳转指令，高 6 位之外的 26 位都是一个跳转后的地址。

![avatar](/img/computer/mips指令集.jpeg)